rv32d
fld
fld rd,rs1,offset
Load a double-precision floating-point value from memory into floating-point register rd.
f[rd] = M[x[rs1] + sext(offset)][63:0]
0000111
i
011
t
fsd
fsd rs2,offset(rs1)
Store a double-precision value from the floating-point registers to memory.
aZM[x[rs1] + sext(offset)] = f[rs2][63:0]
0100111
s
011
t
fmadd.d
fmadd.d rd,rs1,rs2,rs3
Perform double-precision fused multiply addition.
f[rd] = f[rs1]×f[rs2]+f[rs3]
1000011
R4F
01
t
fmsub.d
fmsub.d rd,rs1,rs2,rs3
Perform double-precision fused multiply subtraction.
f[rd] = f[rs1]×f[rs2]-f[rs3]
1000111
R4F
01
t
fnmsub.d
fnmsub.d rd,rs1,rs2,rs3
Perform negated double-precision fused multiply subtraction.
f[rd] = -f[rs1]×f[rs2]+f[rs3]
1001011
R4F
01
t
fnmadd.d
fnmadd.d rd,rs1,rs2,rs3
Perform negated double-precision fused multiply addition.
f[rd] = -f[rs1]×f[rs2]-f[rs3]
1001111
R4F
01
t
fadd.d
fadd.d rd,rs1,rs2
Perform double-precision floating-point addition.
f[rd] = f[rs1] + f[rs2]
1010011
RF
0000001
t
fsub.d
fsub.d rd,rs1,rs2
Perform double-precision floating-point addition.
f[rd] = f[rs1] - f[rs2]
1010011
RF
0000101
t
fmul.d
fmul.d rd,rs1,rs2
Perform double-precision floating-point addition.
f[rd] = f[rs1] × f[rs2]
1010011
RF
0001001
t
fdiv.d
fdiv.d rd,rs1,rs2
Perform double-precision floating-point addition.
f[rd] = f[rs1] / f[rs2]
1010011
RF
0001101
t
fsqrt.d
fsqrt.d rd,rs1
Perform double-precision square root.
f[rd] = sqrt(f[rs1])
1010011
R2F
00000
0101101
t
fsgnj.d
fsgnj.d rd,rs1,rs2
Produce a result that takes all bits except the sign bit from rs1. The result’s sign bit is rs2’s sign bit.
f[rd] = {f[rs2][63], f[rs1][62:0]}
1010011
r
000
0010001
t
fsgnjn.d
fsgnjn.d rd,rs1,rs2
Produce a result that takes all bits except the sign bit from rs1. The result’s sign bit is opposite of rs2’s sign bit.
f[rd] = {~f[rs2][63], f[rs1][62:0]}
1010011
r
001
0010001
t
fsgnjx.d
fsgnjx.d rd,rs1,rs2
Produce a result that takes all bits except the sign bit from rs1. The result’s sign bit is XOR of sign bit of rs1 and rs2.
f[rd] = {f[rs1][63] ^ f[rs2][63], f[rs1][62:0]}
1010011
r
010
0010001
t
fmin.d
fmin.d rd,rs1,rs2
Write the smaller of double precision data in rs1 and rs2 to rd.
f[rd] = min(f[rs1], f[rs2])
1010011
r
000
0010101
t
fmax.d
fmax.d rd,rs1,rs2
Write the larger of double precision data in rs1 and rs2 to rd.
f[rd] = max(f[rs1], f[rs2])
1010011
r
001
0010101
t
fcvt.s.d
fcvt.s.d rd,rs1
Converts double floating-point register in rs1 into a floating-point number in floating-point register rd.
f[rd] = f64->f32(f[rs1])
1010011
R2F
00001
0100000
t
fcvt.d.s
fcvt.d.s rd,rs1
Converts single floating-point register in rs1 into a double floating-point number in floating-point register rd.
f[rd] = f32->f64(f[rs1])
1010011
R2F
00000
0100001
t
feq.d
feq.d rd,rs1,rs2
Performs a quiet equal comparison between double-precision floating-point registers rs1 and rs2 and record the Boolean result in integer register rd. Only signaling NaN inputs cause an Invalid Operation exception. The result is 0 if either operand is NaN.
x[rd] = f[rs1] == f[rs2]
1010011
r
010
1010001
t
flt.d
flt.d rd,rs1,rs2
Performs a quiet less comparison between double-precision floating-point registers rs1 and rs2 and record the Boolean result in integer register rd. Only signaling NaN inputs cause an Invalid Operation exception. The result is 0 if either operand is NaN.
x[rd] = f[rs1] < f[rs2]
1010011
r
001
1010001
t
fle.d
fle.d rd,rs1,rs2
Performs a quiet less or equal comparison between double-precision floating-point registers rs1 and rs2 and record the Boolean result in integer register rd. Only signaling NaN inputs cause an Invalid Operation exception. The result is 0 if either operand is NaN.
x[rd] = f[rs1] <= f[rs2]
1010011
r
000
1010001
t
fclass.d
fclass.d rd,rs1
Examines the value in double-precision floating-point register rs1 and writes to integer register rd a 10-bit mask that indicates the class of the floating-point number. The format of the mask is described in table [classify table]_. The corresponding bit in rd will be set if the property is true and clear otherwise. All other bits in rd are cleared. Note that exactly one bit in rd will be set.
x[rd] = classifys(f[rs1])
1010011
r2
001
00000
1110001
t
fcvt.w.d
fcvt.w.d rd,rs1
Converts a double-precision floating-point number in floating-point register rs1 to a signed 32-bit integer, in integer register rd.
x[rd] = sext(f64->s32(f[rs1]))
1010011
R2F
00000
1100001
t
fcvt.wu.d
fcvt.wu.d rd,rs1
Converts a double-precision floating-point number in floating-point register rs1 to a unsigned 32-bit integer, in integer register rd.
x[rd] = sext(f64->s32(f[rs1]))
1010011
R2F
00001
1100001
t
fcvt.d.w
fcvt.d.w rd,rs1
Converts a 32-bit signed integer, in integer register rs1 into a double-precision floating-point number in floating-point register rd.
x[rd] = sext(f64->s32(f[rs1]))
1010011
R2F
00000
1101001
t
fcvt.d.wu
fcvt.d.wu rd,rs1
Converts a 32-bit unsigned integer, in integer register rs1 into a double-precision floating-point number in floating-point register rd.
f[rd] = u32->f64(x[rs1])
1010011
R2F
00001
1101001
f