rv32i
lui
lui rd,imm
Build 32-bit constants and uses the U-type format. LUI places the U-immediate value in the top 20 bits of the destination register rd, filling in the lowest 12 bits with zeros.
x[rd] = sext(immediate[31:12] << 12)
0110111
u
t
auipc
auipc rd,imm
Build pc-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the 20-bit U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the pc, then places the result in register rd.
x[rd] = pc + sext(immediate[31:12] << 12)
0010111
u
t
jal
jal rd,offset
Jump to address and place return address in rd.
x[rd] = pc+4; pc += sext(offset)
1101111
j
t
jalr
jalr rd,rs1,offset
Jump to address and place return address in rd.
t =pc+4; pc=(x[rs1]+sext(offset))&∼1; x[rd]=t
1100111
i
000
t
beq
beq rs1,rs2,offset
Take the branch if registers rs1 and rs2 are equal.
if (rs1 == rs2) pc += sext(offset)
1100011
b
000
t
bne
bne rs1,rs2,offset
Take the branch if registers rs1 and rs2 are not equal.
if (rs1 != rs2) pc += sext(offset)
1100011
b
001
t
blt
blt rs1,rs2,offset
Take the branch if registers rs1 is less than rs2, using signed comparison.
if (rs1 <s rs2) pc += sext(offset)
1100011
b
100
t
bge
bge rs1,rs2,offset
Take the branch if registers rs1 is greater than rs2, using signed comparison.
if (rs1 >=s rs2) pc += sext(offset)
1100011
b
101
t
bltu
bltu rs1,rs2,offset
Take the branch if registers rs1 is less than rs2, using unsigned comparison.
if (rs1 >u rs2) pc += sext(offset)
1100011
b
110
t
bgeu
bgeu rs1,rs2,offset
Take the branch if registers rs1 is greater than rs2, using unsigned comparison.
if (rs1 >=u rs2) pc += sext(offset)
1100011
b
111
t
lb
lb rd,offset(rs1)
Loads a 8-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.
x[rd] = sext(M[x[rs1] + sext(offset)][7:0])
0000011
i
000
t
lh
lh rd,offset(rs1)
Loads a 16-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.
x[rd] = sext(M[x[rs1] + sext(offset)][15:0])
0000011
i
001
t
lw
lw rd,offset(rs1)
Loads a 32-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.
x[rd] = sext(M[x[rs1] + sext(offset)][31:0])
0000011
i
010
t
lbu
lbu rd,offset(rs1)
Loads a 8-bit value from memory and zero-extends this to XLEN bits before storing it in register rd.
x[rd] = M[x[rs1] + sext(offset)][7:0]
0000011
i
100
t
lhu
lhu rd,offset(rs1)
Loads a 16-bit value from memory and zero-extends this to XLEN bits before storing it in register rd.
x[rd] = M[x[rs1] + sext(offset)][15:0]
0000011
i
101
t
sb
sb rs2,offset(rs1)
Store 8-bit, values from the low bits of register rs2 to memory.
M[x[rs1] + sext(offset)] = x[rs2][7:0]
0100011
s
000
t
sh
sh rs2,offset(rs1)
Store 16-bit, values from the low bits of register rs2 to memory.
M[x[rs1] + sext(offset)] = x[rs2][15:0]
0100011
s
001
t
sw
sw rs2,offset(rs1)
Store 32-bit, values from the low bits of register rs2 to memory.
M[x[rs1] + sext(offset)] = x[rs2][31:0]
0100011
s
010
t
addi
addi rd,rs1,imm
Adds the sign-extended 12-bit immediate to register rs1. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result. ADDI rd, rs1, 0 is used to implement the MV rd, rs1 assembler pseudo-instruction.
x[rd] = x[rs1] + sext(immediate)
0010011
i
000
t
slti
slti rd,rs1,imm
Place the value 1 in register rd if register rs1 is less than the signextended immediate when both are treated as signed numbers, else 0 is written to rd.
x[rd] = x[rs1] <s sext(immediate)
0010011
i
010
t
sltiu
sltiu rd,rs1,imm
Place the value 1 in register rd if register rs1 is less than the immediate when both are treated as unsigned numbers, else 0 is written to rd.
x[rd] = x[rs1] <u sext(immediate)
0010011
i
011
t
xori
xori rd,rs1,imm
Performs bitwise XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd Note, "XORI rd, rs1, -1" performs a bitwise logical inversion of register rs1(assembler pseudo-instruction NOT rd, rs)
x[rd] = x[rs1] ^ sext(immediate)
0010011
i
100
t
ori
ori rd,rs1,imm
Performs bitwise OR on register rs1 and the sign-extended 12-bit immediate and place the result in rd
x[rd] = x[rs1] | sext(immediate)
0010011
i
110
t
andi
andi rd,rs1,imm
Performs bitwise AND on register rs1 and the sign-extended 12-bit immediate and place the result in rd
x[rd] = x[rs1] & sext(immediate)
0010011
i
111
t
slli
slli rd,rs1,shamt
Performs logical left shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate In RV64, bit-25 is used to shamt[5].
x[rd] = x[rs1] << shamt
0010011
shamt
001
0000000
t
srli
srli rd,rs1,shamt
Performs logical right shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate In RV64, bit-25 is used to shamt[5].
x[rd] = x[rs1] >>u shamt
0010011
shamt
101
0000000
t
srai
srai rd,rs1,shamt
Performs arithmetic right shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate In RV64, bit-25 is used to shamt[5].
x[rd] = x[rs1] >>s shamt
0010011
shamt
101
0100000
t
add
add rd,rs1,rs2
Adds the registers rs1 and rs2 and stores the result in rd. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.
x[rd] = x[rs1] + x[rs2]
0110011
r
000
0000000
t
sub
sub rd,rs1,rs2
Subs the register rs2 from rs1 and stores the result in rd. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.
x[rd] = x[rs1] - x[rs2]
0110011
r
000
0100000
t
sll
sll rd,rs1,rs2
Performs logical left shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.
x[rd] = x[rs1] << x[rs2]
0110011
r
001
0000000
t
slt
slt rd,rs1,rs2
Place the value 1 in register rd if register rs1 is less than register rs2 when both are treated as signed numbers, else 0 is written to rd.
x[rd] = x[rs1] <s x[rs2]
0110011
r
010
0000000
t
sltu
sltu rd,rs1,rs2
Place the value 1 in register rd if register rs1 is less than register rs2 when both are treated as unsigned numbers, else 0 is written to rd.
x[rd] = x[rs1] <u x[rs2]
0110011
r
011
0000000
t
xor
xor rd,rs1,rs2
Performs bitwise XOR on registers rs1 and rs2 and place the result in rd
x[rd] = x[rs1] ^ x[rs2]
0110011
r
100
0000000
t
srl
srl rd,rs1,rs2
Logical right shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2
x[rd] = x[rs1] >>u x[rs2]
0110011
r
101
0000000
t
sra
sra rd,rs1,rs2
Performs arithmetic right shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2
x[rd] = x[rs1] >>s x[rs2]
0110011
r
101
0100000
t
or
or rd,rs1,rs2
Performs bitwise OR on registers rs1 and rs2 and place the result in rd
x[rd] = x[rs1] | x[rs2]
0110011
r
110
0000000
t
and
and rd,rs1,rs2
Performs bitwise AND on registers rs1 and rs2 and place the result in rd
x[rd] = x[rs1] & x[rs2]
0110011
r
111
0000000
t
fence
fence pred, succ
Used to order device I/O and memory accesses as viewed by other RISC-V harts and external devices or coprocessors. Any combination of device input (I), device output (O), memory reads ®, and memory writes (W) may be ordered with respect to any combination of the same. Informally, no other RISC-V hart or external device can observe any operation in the successor set following a FENCE before any operation in the predecessor set preceding the FENCE.
Fence(pred, succ)
0001111
fence
000
t
fence.tso
fence.tso
fence.tso
fence.tso
10000011001100000000000000001111
constant
t
pause
pause
pause
pause
00000001000000000000000000001111
constant
t
ecall
ecall
ecall
ecall
00000000000000000000000001110011
constant
t
ebreak
ebreak
ebreak
ebreak
00000000000100000000000001110011
constant
f