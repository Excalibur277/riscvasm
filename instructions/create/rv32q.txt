rv32q
flq
flq rd,offset(rs1)
Load a quad-precision floating-point value from memory into floating-point register rd.
f[rd] = M[x[rs1] + sext(offset)][31:0]
0000111
i
100
t
fsq
fsq rs2,offset(rs1)
Store a quad-precision value from floating-point register rs2 to memory.
aZM[x[rs1] + sext(offset)] = f[rs2][31:0]
0100111
s
100
t
fmadd.q
fmadd.q rd,rs1,rs2,rs3
Perform quad-precision fused multiply addition.
f[rd] = f[rs1]×f[rs2]+f[rs3]
1000011
R4F
11
t
fmsub.q
fmsub.q rd,rs1,rs2,rs3
Perform quad-precision fused multiply addition.
f[rd] = f[rs1]×f[rs2]-f[rs3]
1000111
R4F
11
t
fnmsub.q
fnmsub.q rd,rs1,rs2,rs3
Perform negated quad-precision fused multiply subtraction.
f[rd] = -f[rs1]×f[rs2]+f[rs3]
1001011
R4F
11
t
fnmadd.q
fnmadd.q rd,rs1,rs2,rs3
Perform negated quad-precision fused multiply addition.
f[rd] = -f[rs1]×f[rs2]-f[rs3]
1001111
R4F
11
t
fadd.q
fadd.q rd,rs1,rs2
Perform quad-precision floating-point addition.
f[rd] = f[rs1] + f[rs2]
1010011
RF
0000011
t
fsub.q
fsub.q rd,rs1,rs2
Perform quad-precision floating-point substraction.
f[rd] = f[rs1] - f[rs2]
1010011
RF
0000111
t
fmul.q
fmul.q rd,rs1,rs2
Perform quad-precision floating-point multiplication.
f[rd] = f[rs1] × f[rs2]
1010011
RF
0001011
t
fdiv.q
fdiv.q rd,rs1,rs2
Perform quad-precision floating-point division.
f[rd] = f[rs1] / f[rs2]
1010011
RF
0001111
t
fsqrt.q
fsqrt.q rd,rs1
Perform quad-precision square root.
f[rd] = sqrt(f[rs1])
1010011
R2F
00000
0101111
t
fsgnj.q
fsgnj.q rd,rs1,rs2
Produce a result that takes all bits except the sign bit from rs1. The result’s sign bit is rs2’s sign bit.
f[rd] = {f[rs2][31], f[rs1][30:0]}
1010011
r
000
0010011
t
fsgnjn.q
fsgnjn.q rd,rs1,rs2
Produce a result that takes all bits except the sign bit from rs1. The result’s sign bit is opposite of rs2’s sign bit.
f[rd] = {~f[rs2][31], f[rs1][30:0]}
1010011
r
001
0010011
t
fsgnjx.q
fsgnjx.q rd,rs1,rs2
Produce a result that takes all bits except the sign bit from rs1. The result’s sign bit is XOR of sign bit of rs1 and rs2.
f[rd] = {f[rs1][31] ^ f[rs2][31], f[rs1][30:0]}
1010011
r
010
0010011
t
fmin.q
fmin.q rd,rs1,rs2
Write the smaller of quad precision data in rs1 and rs2 to rd.
f[rd] = min(f[rs1], f[rs2])
1010011
r
000
0010111
t
fmax.q
fmax.q rd,rs1,rs2
Write the larger of quad precision data in rs1 and rs2 to rd.
f[rd] = max(f[rs1], f[rs2])
1010011
r
001
0010111
t
fcvt.s.q
fcvt.s.q rd,rs1
Converts quad floating-point register in rs1 into a single floating-point number in floating-point register rd.
f[rd] = f32->f128(f[rs1])
1010011
R2F
00011
0100000
t
fcvt.q.s
fcvt.q.s rd,rs1
Converts single floating-point register in rs1 into a quad floating-point number in floating-point register rd.
f[rd] = f128->f32(f[rs1])
1010011
R2F
00000
0100011
t
fcvt.d.q
fcvt.d.q rd,rs1
Converts quad floating-point register in rs1 into a double floating-point number in floating-point register rd.
f[rd] = f128->f64(f[rs1])
1010011
R2F
00011
0100001
t
dcvt.q.d
dcvt.q.d rd,rs1
Converts double floating-point register in rs1 into a quad floating-point number in floating-point register rd.
f[rd] = f64->f128(f[rs1])
1010011
R2F
00001
0100011
t
feq.q
feq.q rd,rs1,rs2
Performs a quiet equal comparison between quad-precision floating-point registers rs1 and rs2 and record the Boolean result in integer register rd. Only signaling NaN inputs cause an Invalid Operation exception. The result is 0 if either operand is NaN.
x[rd] = f[rs1] == f[rs2]
1010011
R2F
00000
1110000
t
flt.q
flt.q rd,rs1,rs2
Performs a quiet less comparison between quad-precision floating-point registers rs1 and rs2 and record the Boolean result in integer register rd. Only signaling NaN inputs cause an Invalid Operation exception. The result is 0 if either operand is NaN.
x[rd] = f[rs1] < f[rs2]
1010011
r
001
1010000
t
fle.q
fle.q rd,rs1,rs2
Performs a quiet less or equal comparison between quad-precision floating-point registers rs1 and rs2 and record the Boolean result in integer register rd. Only signaling NaN inputs cause an Invalid Operation exception. The result is 0 if either operand is NaN.
x[rd] = f[rs1] <= f[rs2]
1010011
r
000
1010000
t
fclass.q
fclass.q rd,rs1
Examines the value in quad-precision floating-point register rs1 and writes to integer register rd a 10-bit mask that indicates the class of the floating-point number. The format of the mask is described in [classify table]_. The corresponding bit in rd will be set if the property is true and clear otherwise. All other bits in rd are cleared. Note that exactly one bit in rd will be set.
x[rd] = classify_s(f[rs1])
1010011
r2
001
00000
1110000
t
fcvt.w.q
fcvt.w.q rd,rs1
Converts a quad-precision floating-point number in floating-point register rs1 to a signed 32-bit integer, in integer register rd.
x[rd] = sext(f128->s32(f[rs1]))
1010011
R2F
00000
1100011
t
fcvt.wu.q
fcvt.wu.q rd,rs1
Converts a quad-precision floating-point number in floating-point register rs1 to a unsigned 32-bit integer, in integer register rd.
x[rd] = sext(f128->s32(f[rs1]))
1010011
R2F
00001
1100011
t
fcvt.q.w
fcvt.q.w rd,rs1
Converts a 32-bit signed integer, in integer register rs1 into a quad-precision floating-point number in floating-point register rd.
x[rd] = sext(f128->s32(f[rs1]))
1010011
R2F
00000
1101011
t
fcvt.q.wu
fcvt.q.wu rd,rs1
Converts a 32-bit unsigned integer, in integer register rs1 into a quad-precision floating-point number in floating-point register rd.
f[rd] = u32->f128(x[rs1])
1010011
R2F
00001
1101011
f